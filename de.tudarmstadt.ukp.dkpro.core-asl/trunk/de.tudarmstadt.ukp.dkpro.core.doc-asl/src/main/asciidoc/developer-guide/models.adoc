// Copyright 2013
// Ubiquitous Knowledge Processing (UKP) Lab
// Technische Universit√§t Darmstadt
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[sect_models]]

== Models and Resources

This section explains how resources, such as models, are packaged, distributed, and used
within DKPro Core. 



=== Architecture

The architecture for resources (e.g. parser models, POS tagger models, etc.) in DKPro is
still work in progress. However, there are a couple of corner points that have already
been established.


* __REQ-1__ - Addressable by URL: Resources must be addressable
					using an URL, typically a classpath URL
						(classpath:/de/tudarmstadt/.../model.bin) or a file URL
						(file:///home/model.bin). Remote URLs like HTTP should not be
					used and may not be supported.


* __REQ-2__ - Maven compatible: Resources are packaged in JARs
					and can be downloaded from our Maven repositories (if the license permits).
				


* __REQ-3__ - Document-sensitive: A component should
					dynamically determine at runtime which resource to use based on properties of a
					processed document, e.g. based on the document language. This may change from
					one document to the next.


* __REQ-4__ - Overridable: The user should be able to override
					the model or provide additional information as to what specific variant of a
					resource should be used. E.g. if there are two resources for the language de,
						++de-fast++ and ++de-accurate++, the component
					could use ++de-fast++ per default unless the user specifies to
					use variante accurate or specifies a different model altogether. 


* __REQ-5__ - Loadable from classpath: Due to REQ-1, REQ-2, and
					REQ-3 models must be resolvable from the classpath. 
** ++ResourceUtils.resolveLocation(String, Object, UimaContext)++
** Resource Providers (see below) 
** ++PathMatchingResourcePatternResolver++


==== Versioning scheme

To version our packaged models, we use a date (yyyymmdd) and a counter (x). We use a date,
because often no (reliable) upstream version is available. E.g. with the Stanford
NLP tools, the same model is sometimes included in different pacakges with different
versions (e.g. parser models are included with the CoreNLP package and the parser
package). TreeTagger models are not versioned at all. With the OpenNLP version, we
are not sure if they are versioned - it seems they are just versioned for
compatibility with a particular OpenNLP version (e.g. 1.5.) but have no proper
version of their own. If we know it, we use the date when the model was last
changed, otherwise we use the date when we first package a new model and update it
when we observe a model change.

We include additional metadata with the packaged model (e.g. which tagset is used)
and we sometimes want to release packaged models with new metadata, although the
upstream model itself has not changed. In such cases, we increment the counter. The
counter starts at 0 if a new model is incorporated.

Thus, a model version has the format "yyyymmdd.x".


=== Packaging resources

Resources needed by DKPro components (e.g. parser models or POS tagger models) are not
			packaged with the corresponding analysis components, but as separate JARs, one per
			language and model variant. 

Due to license restrictions, we may not redistribute all of these resources. But, we
			offer Ant scripts to automatically download the resources and package them as
			DKPro-compatible JARs. When the license permits, we upload these to our public Maven
			repository. 

If you need a non-redistributable resource (e.g. TreeTagger models) or just want to
			package the models yourself, here is how you do it.



==== Installing Ant in Eclipse

Our build.xml scripts require Ant 1.8.x. If you use an older Eclipse version, you may have
				to manually download and register a recent Ant version: 


* Download the latest Ant binaries from the website and unpack them in a
						directory of your choice.


* Start Eclipse and go to __Window &gt; Preferences &gt; Ant &gt; Runtime__ and press __Ant Home...__.


* Select the Ant directory you just unpacked, then confirm.



==== Implementing a build.xml script

Models are usually large and we therefore package them separately from the components that use them. 
Each model becomes a JAR that is uploaded to our Maven repositories and added as a dependency in the
projects that use them.

Often, models are single files, e.g. serialize Java objects that represent a
parser model, POS tagger model, etc. The simplest case is that these files are
distributed from some website. We use an Ant script then to download the file and
package it as a JAR. We defined custom Ant macros like install-model-file that make
the process very convenient. The following code shows how we import the custom
macros and define two targets, local-maven and separate-jars. The first just sets a
property to cause install-model-file to copy the finished JAR into the local Maven
repository (`~.m2/repository`). 

The versioning scheme for models is "yyyymmdd.x" where "yyyymmdd" is the date of
the last model change (if known) or the date of packaging and "x" is a counter
unique per date starting a 0. Please refer to the versioning scheme documentation
for more information. 

The model building ANT script goes to `src/scripts/build.xml` with the project.


[source,xml]
----
<project basedir="../.." default="separate-jars">
  <import>
    <url url="http://dkpro-core-asl.googlecode.com/svn/built-ant-macros/
      tags/0.6.0/ant-macros.xml"/>
  </import>
        
  <!-- 
      - Output package configuration
    -->
  <property name="outputPackage" 
     value="de/tudarmstadt/ukp/dkpro/core/opennlp/lib"/>

  <target name="local-maven">
    <property name="install-artifact-mode" value="local"/>
    <antcall target="separate-jars"/>
   </target>

  <target name="remote-maven">
    <property name="install-artifact-mode" value="remote"/>
    <antcall target="separate-jars"/>
  </target>
        
  <target name="separate-jars">
    <mkdir dir="target/download"/>
        
    <!-- FILE: models-1.5/en-pos-maxent.bin - - - - - - - - - - - - - - 
      - 2012-06-16 | now        | db2cd70395b9e2e4c6b9957015a10607
      -->
    <get 
      src="http://opennlp.sourceforge.net/models-1.5/en-pos-maxent.bin"
      dest="target/download/en-pos-maxent.bin"
      skipexisting="true"/>
    <install-stub-and-upstream-file 
      file="target/download/en-pos-maxent.bin"
      md5="db2cd70395b9e2e4c6b9957015a10607"
      groupId="de.tudarmstadt.ukp.dkpro.core"
      artifactIdBase="de.tudarmstadt.ukp.dkpro.core.opennlp"
      upstreamVersion="20120616"
      metaDataVersion="1"
      tool="tagger"
      language="en" 
      variant="maxent" 
      extension="bin" >
        <metadata>
          <entry key="pos.tagset" value="ptb"/>
        </metadata>
    </install-model-file>
  </target>
</project>
----

The model file `en-pos-maxent.bin` is downloaded from the OpenNLP website and stored in a local 
cache directory	`target/download/tagger/da-pos-maxent.bin`. From there, 
`install-stub-and-upstream-file` picks it up and packages it as two JARs, 1) a JAR
containing the DKPro Core meta data and a POM referencing the second JAR, 2) a JAR
containing the actual model file(s). The JAR file names derive from the
artifactIdBase, tool, language, variant, upstreamVersion and metaDataVersion
parameters. These parameters along with the extension parameter are also used to
determine the package name and file name of the model in the JAR. They are
determined as follows (mind that dots in the artifactBase turn to slashes, e.g.
`de.tud` turns `de/tud`: 

.Pattern used to place a resource within a JAR
----
{artifactIdBase}/lib/{tool}-{language}-{variant}.{extension}
----

The following values are commonly used for __tool__: 

* `token` - tokenizer 
* `sentence` - sentence splitter 
* `lemmatizer` - lemmatizer 
* `tagger` - part-of-speech tagger 
* `morphtagger` - morphological analyzer 
* `ner` - named-entity recognizer
* `parser` - syntactic or dependency parser
* `coref` - coreference resolver

The values for *variant* are very tool-dependent. Typically,
the variant encodes parameters that were used during the creation of a model, e.g.
which machine learning algorithm was used, which parameters it had, and on which
data set is has been created. 

An md5 sum for the remote file must be specified to make sure we notice if the
remote file changes or if the download is corrupt. 

The metadata added for the models currently used to store tagset information,
which is used to drive the tag-to-DKPro-UIMA-type mapping. The following values are
commonly used as keys: 

* `pos.tagset` - part-of-speech tagset (ptb, ctb, stts, ...) 
* `dependency.tagset` - dependency relation labels, aka. syntactic functions (negra, ancora, ...) 
* `constituent.tagset` - constituent labels, aka. syntactic categories (ptb, negra, ...) 


==== Running the build.xml script

For those modules where we support packaging resources as JARs, we provide an Ant script
called `build.xml` which is located in the corresponding module
in the SVN. 

`build.xml` is a script that can be run with Apache Ant (version 1.8.x or higher) and requires an 
internet connection. 

You can find this script in the `src/scripts` folder of the module. 

Depending on the script, various build targets are supported. Three of them are
				particularly important: __separate-jars__,
					__local-maven__, and __remote-maven__:


* __separate-jars__ downloads all resource from the
							internet, validates them against MD5 checksums and packages them as
							DKPro-compatible JARs. The JARs are stored to the target folder. You can
							easily update them to an Artifactory Maven repository. Artifactory
							automatically recognizes their group ID, artifact ID and version. This
							may not work with other Maven repositories. 


* __local-maven__ additionally installs the JARs into
							your the local Maven repository on your computer. It assumes the default
							location of the repository at __$$~/.m2/repository$$__. If
							you keep your repository in a different folder, specify it via the
								__alt.maven.repo.path__ system property.


* __remote-maven__ additionally installs the JARS into
							a remote Maven repository. The repository to deploy to can be controlled
							via the system property alt.maven.repo.url. If the remote repo also
							requires authentication, use the system property
								__alt.maven.repo.id__ to configure the credentials
							from the settings.xml that should be used. An alternative settings file
							can be configured using __alt.maven.settings__.

[NOTE]
====
This target requires that you have installed link:$$http://repo1.maven.org/maven2/org/apache/maven/maven-ant-tasks/2.1.3/maven-ant-tasks-2.1.3.jar$$[__maven-ant-tasks-2.1.3.jar__] in
									__$$~/.ant/lib$$__.

====


It is recommended to open the __build.xml__ file in
				Eclipse, run the __local-maven__ target, and then restart Eclipse.
				Upon restart, Eclipse should automatically scan your local Maven repository. Thus,
				the new resource JARs should be available in the search dialog when you add
				dependencies in the POM editor. 



==== Example: how to package TreeTagger binaries and models

TreeTagger and its models cannot be re-distributed with DKPro Core, you need to download it
				yourself. For your convenience, we included an Apache Ant script called
					__build.xml__ in the __src/scripts__ folder of
				the TreeTagger module. This script downloads the TreeTagger binaries and models and
				packages them as artifacts, allowing you to simply add them as dependencies in
				Maven. 

To run the script, you need to have Ant 1.8.x installed and configured in Eclipse.
				This is already the case with Eclipse 3.7.x. If you use an older Eclipse version,
				please see the section below on installing Ant in Eclipse. 

Now to build the TreeTagger artifacts: 


* Locate the Ant build script (__build.xml__) in the
						scripts directory (__src/scripts__) of the
							__de.tudarmstadt.ukp.dkpro.core.treetagger__ module.
					


* Right-click, choose __Run As &gt; External Tools Configurations__. In the __Target__ tab,
						select local-maven, run. 


* Read the license in the Ant console and - if you care - accept the license
						terms. 


* Wait for the build process to finish.


* Restart Eclipse 

To use the packaged TreeTagger resources, add them as Maven dependencies to your
				project (or add them to the classpath if you do not use Maven). 

Note that in order to use TreeTagger you must have added at least the JAR with the
				TreeTagger binaries and one JAR with the model for the language you want to work
				with.


=== Updating a model

Whenever one existing model have a new release, it is good to update the build.xml changing
			the: 


* URL for retrieving the model (if it has changed) 


* The version from the model (the day when the model was created in the yyyymmdd
					format) 

After that, run the ant script with the __local-maven__ target, add
			the jars to your project classpath and check if the existing unit tests work for the up
			to date model. If they do, then run the script again, this time with the
				__remote-maven__ target. Then, change the versions from the models
			in the dependency management section from the project's pom file, commit those changes
			and move these new models from staging into model repository on zoidberg. 



==== MD5 checksum check fails

Not all of the resources are properly versioned by their maintainers (in particular
				TreeTagger binaries and models). We observed that resources changed from one day to
				the next without any announcement or increase of the version number (if present at
				all). Thus, we validate all resources against an MD5 checksum stored in the
					__build.xml__ file. This way, we can recognize if a remote
				resource has been changed. When this happens, we add a note to the
					__build.xml__ file indicating, when we noticed the MD5 changed
				and update the version of the corresponding resource.

Since we do not test the build.xml files every day, you may get an MD5 checksum
				error when you try to package the resources yourself. If this happens, open the
				build.xml file with a text editor, locate the MD5 checksum that fails, update it and
				update the version of the corresponding resource. You can also tell us on the DKPro
				Core User Group and we will update the __build.xml__ file.



=== Using Resource Providers

The ++CasConfigurableProviderBase++ class provides some support for the above
			requirements. The following code is taken from the ++OpenNlpPosTagger++
			component. It shows how the POS Tagger model is addressed using a parametrized classpath
			URL with parameters for language and variant. The ++produceResource()++ method
			is called with the URL of the model once it has been located by
				++CasConfigurableProviderBase++. 


[source,java]
----
modelProvider = new CasConfigurableStreamProviderBase<POSTagger>() {
    {
        // These are the default values
        setDefault(LOCATION, "classpath:/de/tudarmstadt/ukp/dkpro/core/" +
                "opennlp/lib/tagger-${language}-${variant}.bin");
        setDefault(VARIANT, "maxent");
                                
        // These are parameters the user may have set on the component,
        // they may be null
        setOverride(LOCATION, modelLocation);
        setOverride(LANGUAGE, language);
        setOverride(VARIANT, variant);
    }
                        
    @Override
    protected POSTagger produceResource(InputStream aStream) 
      throws Exception
    {
        POSModel model = new POSModel(aStream);
        return new POSTaggerME(model);
    }
};

// Here the language is picked up from the CAS.
modelProvider.configure(cas);

// Here we get the tagger according to the language, variant and location 
// chosen. A new instance is only created if necessary (e.g. if the
// current CAS has a different language than the previous).
POSTagger tagger = modelProvider.getResource();
----


[NOTE]
====
This is an illustrative code example. See link:$$http://code.google.com/p/dkpro-core-asl/source/browse/de.tudarmstadt.ukp.dkpro.core-asl/trunk/de.tudarmstadt.ukp.dkpro.core.opennlp-asl/src/main/java/de/tudarmstadt/ukp/dkpro/core/opennlp/OpenNlpPosTagger.java$$[++OpenNlpPosTagger++] for the complete code.

====




==== Mapping Providers

The DKPro type system design provides two levels of abstraction on most annotations: 


* a generic annotation type, e.g. POS (part of speech) with a feature value
						containing the original tag produced by an analysis component, e.g.
						TreeTagger 


* a set of high-level types for very common categories, e.g. N (noun), V
						(verb), etc. 

DKPro maintains mappings for commonly used tagsets, e.g. in the module
					__de.tudarmstadt.ukp.dkpro.core.api.lexmorph-asl__. They are
				named: 


----
{language}-{layer}.map
----

The following values are commonly used for __layer__: 


* ++pos++ - part-of-speech tag mapping 

Mapping providers are a convenient way of fetching a mapping between the original
				tag value and the high-level types. 


[source,java]
----
// General setup of the mapping provider in initialize()
mappingProvider = new MappingProvider();
mappingProvider.setDefault(MappingProvider.LOCATION, 
    "classpath:/de/tudarmstadt/ukp/dkpro/" +
    "core/api/lexmorph/tagset/${language}-pos.map");
mappingProvider.setDefault(MappingProvider.BASE_TYPE, POS.class.getName());
mappingProvider.setOverride(MappingProvider.LOCATION, mappingLocation);
mappingProvider.setOverride(MappingProvider.LANGUAGE, language);

// Document-specific configuration in process()
mappingProvider.configure(cas);

// Resolve an original tag value to a high-level type
Type posTag = mappingProvider.getTagType(tags[i]);
POS posAnno = (POS) cas.createAnnotation(posTag, t.getBegin(), t.getEnd());
----


[NOTE]
====
This is an illustrative code example. See link:$$http://code.google.com/p/dkpro-core-asl/source/browse/de.tudarmstadt.ukp.dkpro.core-asl/trunk/de.tudarmstadt.ukp.dkpro.core.opennlp-asl/src/main/java/de/tudarmstadt/ukp/dkpro/core/opennlp/OpenNlpPosTagger.java$$[++OpenNlpPosTagger++] for the complete code.

====




==== Language-dependent default variants

It is possible a different default variant needs to be used depending on the language. This
				can be configured by placing a properties file in the classpath and setting its
				location using ++setDefaultVariantsLocation(String)++. The key in the
				properties is the language and the value is used a default variant. These file
				should always reside in the libsub-package of a component and use the naming
				convention: 


----
{tool}-default-variants.map
----


----
// General setup of the mapping provider in initialize()
mappingProvider.setDefaultVariantsLocation("de/tudarmstadt/ukp/dkpro/" +
    "core/stanfordnlp/lib/tagger-default-variants.map");
----


[NOTE]
====
This is an illustrative code example. See link:$$http://code.google.com/p/dkpro-core-gpl/source/browse/de.tudarmstadt.ukp.dkpro.core-gpl/trunk/de.tudarmstadt.ukp.dkpro.core.stanfordnlp/src/main/java/de/tudarmstadt/ukp/dkpro/core/stanfordnlp/StanfordPosTagger.java$$[++StanfordPosTagger++] for the complete code.

====


The __tagger-default-variants.map__ is a Java properties file
				which defines for each language which variant should be assumed as default. 


----
ar=fast
de=fast
en=bidirectional-distsim-wsj-0-18
zh=default
----

